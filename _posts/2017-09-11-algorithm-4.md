---
title: 탐색공간의 배제
categories:
- algorithm
tag:
- cpp
---

탐색공간의 배제는 전체탐색 알고리즘을 구현하는 데 있어서 더 이상 탐색하지 않더라도 해를 구하는 데 문제가 없는 부분을 판단하여 이 부분에 대해서 탐색을 하지않고 탐색의 효율을 높이고자 하는 방법이다.

배제되는 탐색공간의 크기에 따라 알고리즘의 성능의 향상 폭이 달라진다. 잘못 설계를 하면 해를 구할 수 없는 경우가 발생하므로 탐색 영역을 배제할 때는 수학적 접근이 필요하다.

### 1. 수학적 배제
- 이분탐색 알고리즘 : 수학적 배제를 이용해 탐색공간을 줄여나가는 알고리즘 설계방법
오름차순으로 정렬된 상태의 이분탐색에서 현재 탐색한 값이 목표하는 값보다 작다면, 왼쪽 영역에는 해가 존재할 가능성이 없으므로 배제할 수 있다.

수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다. 이 방법은 일종의 **Greedy(탐욕법)**이라고 할 수 있다.
수학적 배제는 단순히 직관적으로 배제의 규칙을 결정하면 최적해를 구할 수 있음을 보장할 수 없다.

#### 약수구하기

영역배제
1. 모든 자연수 n에 대해 1과 n은 항상 n의 약수이다.
2. 모든 자연수 n에 대하여, 2이상 n미만의 자연수들 중 가장 큰 n 의 약수는 n/2를 넘지 않는다.
3. n = d(k) X d(c-k+1) k번째 원소와 c-k+1번째 원소의 곱은 항상 n이다.

```cpp
for(i=2;i*i<=n;i++)
   if(n%i==0)sum+=(i+n/i);
if(i*i==n)sum+=i;
```

#### 소수구하기

- 약수가 2개를 초과한다면 더 이상 탐색할 필요가 없다.
- n이 소수라면 약수는 1과 n만 존재한다. 즉, 구간[2,n]에서 약수는 존재하지 않는다.
- O(n^1/2)

```cpp
for(int i=2;i*i<=k;i++){
	if(k%i==0)return false;
}
```
- **에라토스테네스의 체**
	1. 2부터 n까지 차례로 숫자를 쓰고, 2부터 탐색을 시작
	2. 현재 탐색 중인 수가 지워지지 않았으면 그 수는 소수이다.
	3. 1단계에서 그 수가 소수이면 그 수의 배수를 모두 지운다.
	4. 만약 아직 탐색이 끝나지 않았으면 다음 수를 탐색할 준비를 하고 1단계로간다.
	5. 지워지지 않은 모든 수는 소수, 지워진 수는 합성수이다.

#### 소수구하기 심화

어떤 수에서 자릿수의 위치를 바꾸었을때 소수인것을 구하시오. ex) 23은소수, 32는 합성수

1. 입력된 수의 자릿수를 분리하여 배열에 넣는다.
2. 분리된 각 자릿수로 모든 경우의 순열을 만든다.
3. 만들어진 순열들을 오름차순으로 정렬한다.
4. 각각의 순열에 대해 소수인지 확인한다.
5. 소수이고 한 번도 출력하지 않았다면 출력한다.
6. 소수가 하나도 없었으면 -1을 출력한다.

### 2. 경험적 배제

경험적 배제는 전체탐색법을 기본으로 한 알고리즘 설계 방법이다. 특정 조건(더 이상 탐색하더라도 해를 구할 수 없음을 판달할 수 있는 조건)을 두고, 이 조건을 기준으로 해가 될 수 있는 모든 공간을 탐색해 나간다. 특정조건은 탐색을 진행하는 중에 조건을 설정하고, 탐색한 영역이 넓어질수록 상황에 따라 조건이 갱신된다.
경험적 배제는 일반적으로 **가지치기**(branch & bound)라고 한다.
일반적으로 더 이상 탐색할 정점이 없어서 되돌아 오는 것을 백트랙이라고 한다. 하지만 더 탐색할 공간이 있음에도 불구하고 돌아오는 흐름을 **바운딩(bounding)** 혹은 **커팅(cutting)**이라고한다.

**핵심은 더 이상 탐색할 필요가 없는 지점을 판단하는 기준을 정하는 것이다.**

