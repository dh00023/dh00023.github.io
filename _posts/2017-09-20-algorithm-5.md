---
title: "03. Dynamic Programming"
tag: algorithm
---

큰 문제를 작은 문제로 나눠서 푸는 알고리즘이다.

1. **Overlapping Subproblem** (겹치는 부분문제)
2. **Optimal Substructure**(문제의 정답을 작은 부분에서 알 수 있을 때)

이 두가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다.

### Overlapping Subproblem
- 문제 : N번째 피보나치 수를 구하는 문제
- 작은문제 : <span style="color:blue">N-1번째 피보나치 수를 구하는 문제</span>, <span style="color:red">N-2번째 피보나치 수를 구하는 문제</span>


- 문제 : <span style="color:blue">N-1번째 피보나치 수를 구하는 문제</span>
- 작은문제 : <span style="color:red">N-2번째 피보나치 수를 구하는 문제</span>, <span style="color:green">N-3번째 피보나치 수를 구하는 문제</span>


- 문제 : <span style="color:red">N-2번째 피보나치 수를 구하는 문제</span>
- 작은문제 : <span style="color:green">N-3번째 피보나치 수를 구하는 문제</span>, N-3번째 피보나치 수를 구하는 문제

작은 문제가 겹쳐야한다. 큰 문제와 작은 문제는 상대적이다.

1. 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
2. 문제를 작은 문제로 쪼갤 수 있다.

### Optimal Substructure
문제의 정답을 작은 문제의 정답에서 구할 수 있다.

N-1번째 피보나치 수를 구하는 문제 = N-2번째 피보나치 수를 구하는 문제 + N-3번째 피보나치 수를 구하는 문제

## 다이나믹 프로그래밍

- 각 문제는 한번만 풀어야 한다.
- 같은 문제는 구할 때마다 정답이 같다.(Optimal Substructure)
- 정답을 구했으면, 정답을 어딘가에 메모해놓는다.(**배열**)=>**Memoization**


### Top-down
1. 문제를 작은 문제로 나눈다.
2. 작은 문제를 푼다.
3. 작은 문제를 풀었으니, 이제 문제를 푼다.

**재귀호출**을 이용해서 문제를 쉽게 풀 수 있다.
시간복잡도는 채워야하는 칸의 수 X 한 칸을 채우는 복잡도(함수하나의 시간 복잡도)이다.

```cpp
int memo[100]; //memoization
int fibonacci(int n){
	if(n<=1){
    	return n;
    }else{
    	if(memo[n]>0){
        	return memo[n];
        }
        memo[n] = fibonacci(n-1)+fibonacci(n-2);
        return memo[n];
    }
}
```

### Bottom-up
1. 문제를 크기가 작은 문제부터 차례대로 푼다.
2. 문제의 크기를 조금씩 크게 만들면서 문제를 푼다.
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.

```cpp
int d[100];
int fibonacci(int n){
	d[0]=1;
    d[1]=1;
    for(int i=2;i<=n;i++){
    	d[i]=d[i-1]+d[i-2];
    }
    return d[n];
}
```

memoization을 할 때 무엇을 기록해야할지 정의하는 것이 최우선이다.

#### 1로 만들기
D[N] = N을 1로 만드는데 필요한 연산의 최솟값
1. N이 3으로 나누어 떨어지면, 3으로 나눈다. `D[N/3]+1`
2. N이 2로 나누어 떨어지면, 2로 나눈다. `D[N/2]+1`
3. 1을 뺀다. `D[N-1]+1`

=> **D[N]=min(1,2,3)**

- Top-down

```cpp
#include <iostream>

//Top-Down(재귀)
int d[1000001];
int divn(int n){
    if(n==1) return 0;
    if(d[n]>0) return d[n];
    //-1
    d[n]=divn(n-1)+1;
    if(n%2==0){
        int temp=divn(n/2)+1;
        if(d[n]>temp) d[n] = temp;
    }
    if(n%3==0){
        int temp=divn(n/3)+1;
        if(d[n]>temp) d[n] = temp;
    }
    return d[n];
}
```

- bottom-up

```cpp
//Bottom-up
void divbu(int n){
    d[1]=0;
    for(int i=2;i<=n;i++){
        d[i]=d[i-1]+1;
        if(i%2==0 && d[i]>d[i/2]+1){
            d[i]=d[i/2]+1;
        }
        if(i%3==0 && d[i]>d[i/3]+1){
            d[i]=d[i/3]+1;
        }
    }
    printf("%d",d[n]);
}
```

#### 2Xn 타일링
2Xn 직사각형을 1x2,2x1타일로 채우는 방법의 수
=> **D[n]=2xi직사각형을 채우는 방법의 수**
=> **D[n]=D[n-1]+D[n-2]**

이 때, n=0일 때도 경우의 수이기 때문에 1을 출력한다.

- Bottom-up

```cpp
#include <iostream>
using namespace std;

int d[10001];
int main() {
    int x;
    cin >> x;
    d[1]=1;
    d[0]=1;
    for(int i=2;i<=x;i++){
        d[i]=d[i-1]+d[i-2];
        d[i]%=10007;
    }
    cout << d[x] << "\n";
}
```

#### 2xn 타일링 2

2Xn 직사각형을 1x2,2x1,2x2타일로 채우는 방법의 수
=> **D[n]=2xi직사각형을 채우는 방법의 수**
=> **D[n]=D[n-1]+2*D[n-2]**

- Bottom-up

```cpp
#include <iostream>
using namespace std;

int d[10001];
int main() {
    int x;
    cin >> x;
    d[1]=1;
    d[0]=1;
    for(int i=2;i<=x;i++){
        d[i]=d[i-1]+2*d[i-2];
        d[i]%=10007;
    }
    cout << d[x] << "\n";
}
```

#### 1,2,3 더하기
정수 n을 1,2,3의 조합으로 나타내는 방법의 수를 구하는 문제
=> **D[n]=정수 n을 1,2,3의 조합으로 나타내는 방법의 수**
=> **마지막에 오는 수가 중요하다.**
=> **D[n]=D[n-1]+D[n-2]+D[n-3]**

- Bottom-up

```cpp
#include <iostream>
using namespace std;

int d[10001];
int main() {
    int t;
    cin >> t;
    while(t--){
        int x;
        cin >> x;
        d[1]=1;
        d[0]=1;
        d[2]=2;
        for(int i=2;i<=x;i++){
            d[i]=d[i-1]+d[i-2]+d[i-3];
        }
        cout << d[x] << "\n";
    }
}
```

#### 붕어빵 판매하기
붕어빵 i개를 팔아서 얻을 수 있는 수익 P[i]일 때, N개를 모두 판매해서 얻을 수 있는 최대 수익구하기
=> **D[n]=n개를 모두 판매해서 얻을 수 있는 최대수익**