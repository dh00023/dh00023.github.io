---
title: "2. 자료구조"
tag: algorithm
---
구현하는 것보다 짜여져 있는 것을 쓰는게 좋다.

## 스택

한쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조이다.
- **LIFO**(Last In First Out) 마지막으로 넣은 것이 가장 먼저 나온다.

|연산|설명|
|------|------|
|push|스택에 자료를 넣는 연산|
|pop|스택에서 자료를 빼는 연산|
|top|스택의 가장 위에 있는 자료를 보는 연산|
|empty|스택이 비어있는지 아닌지를 알아보는 연산|
|size|스택에 저장되어있는 자료의 개수를 알아보는 연산|

![](http://lh4.ggpht.com/-yPC1y5pyEK8/UI5YdsZz_oI/AAAAAAAAA1Y/zSzytUOxVWA/clip_image001_thumb%25255B1%25255D.gif?imgmax=800)

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;


int main ()
{
    stack<int> mystack;
    int n;
    scanf("%d",&n);

    while(n--){
        string ss;
        cin >> ss;

        if(ss=="push"){
            int num;
            scanf("%d",&num);
            mystack.push(num);
        } else if(ss=="top"){
            cout << (mystack.empty() ? -1 : mystack.top())<<"\n";
        } else if(ss=="size"){
            cout << mystack.size()<<"\n";
        } else if(ss=="empty"){
            cout << mystack.empty()<<"\n";
        } else if(ss=="pop"){
            cout << (mystack.empty() ? -1 : mystack.top())<<"\n";
            if(!mystack.empty()){
                mystack.pop();
            }
        }
    }
}
```
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;
struct Stack {
    int data[10000];
    int size;
    Stack() {
        size = 0;
    }
    void push(int num) {
        data[size] = num;
        size += 1;
    }
    bool empty() {
        if (size == 0) {
            return true;
        } else {
            return false;
        }
    }
    int pop() {
        if (empty()) {
            return -1;
        } else {
            size -= 1;
            return data[size];
        }
    }
    int top() {
        if (empty()) {
            return -1;
        } else {
            return data[size-1];
        }
    }
};
int main() {
    int n;
    cin >> n;

    Stack s;

    while (n--) {
        string cmd;
        cin >> cmd;
        if (cmd == "push") {
            int num;
            cin >> num;
            s.push(num);
        } else if (cmd == "top") {
            cout << (s.empty() ? -1 : s.top()) << '\n';
        } else if (cmd == "size") {
            cout << s.size << '\n';
        } else if (cmd == "empty") {
            cout << s.empty() << '\n';
        } else if (cmd == "pop") {
            cout << (s.empty() ? -1 : s.top()) << '\n';
            if (!s.empty()) {
                s.pop();
            }
        }
    }
    return 0;
}
```

### 실습

- 괄호(VPS)
	- 올바른 괄호 문자열의 예시
		- ()
		- (())()
		- ((()))
	- 올바른 괄호 문자열이 아닌 예
		- (()(
		- (()()))
		- (()

스택을 이용해서 괄호 문자열인지 아닌지 알 수 있다.
1. `(`가 나오면 스택에 넣는다.
2. `)`가 나오면 스택에서 하나를 빼서 `(`인지 확인한다.

시간복잡도 O(N^2)

=> 스택을 이용해서 O(N)을 O(1)로 줄일 수 있다.


[예시]
- <b style="color: red;">(</b>())()
스택: (
- (<b style="color: red;">(</b>))()
스택: ((
- ((<b style="color: red;">)</b>)()
스택: (
- (()<b style="color: red;">)</b>()
스택:
- (())<b style="color: red;">(</b>)
스택: (
- (())(<b style="color: red;">)</b>
스택:

모든 과정이 끝난 후 스택이 비어있으므로 올바른 괄호 문자열이다.
만약 모든 과정이 끝난 후 스택이 비어있지 않으면 올바른 괄호 문자열이 아니다.

그러므로 스택에 **몇개(size)**가 들어가 있는지가 중요하다!

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

string valid(string s){
    int cnt=0;
    for(int i=0;i<=s.size();i++){
        if(s[i]=='('){
            cnt += 1;
        }else if(s[i]==')'){
            cnt -= 1;
        }
        if (cnt < 0) {
            return "NO";
        }
    }
    if (cnt == 0) {
        return "YES";
    }else{
        return "NO";
    }
}
int main(){
    int t;
    cin >> t;

    while(t--){
        string ps;
        cin >> ps;

        cout<<valid(ps)<<"\n";
    }
}
```


- 쇠막대기
	- 레이저는 여는 괄호와 닫는 괄호의 **인접한(인덱스 중요)** 쌍 `()`으로 표현한다. 또한, 모든 `()`는 반드시 레이저를 표현한다.
	- 쇠막대기의 왼쪽 끝은 `(`로, 오른쪽 끝은 닫힌 괄호`)`로 표현한다.

1. `()`가 나올 때마다 스택에 들어 있는 `(`의 개수를 세어준다.
2. `)`가 나왔을 때는 레이저인지 쇠막대기 인지 구분을 해준다.
3. 레이저는 항상 붙어진 상태로 나오므로 스택의 `(`의 인덱스와 1차이가 나는지 확인해야한다.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main(){
    stack<int> s;

    int cnt=0;
    string ps;
    cin >> ps;

    for(int i=0;i<=ps.size();i++){
        if(ps[i]=='('){
            s.push(i);
        }else if(ps[i]==')'){
            if(i==s.top()+1){
                s.pop();
                cnt+=s.size();
            }else{
                s.pop();
                cnt+=1;
            }
        }
    }
    cout << cnt << "\n";
}
```

- 에디터
	- 커서는 문장의 맨 앞, 맨 뒤, 중간 임의의 곳에 위차할 수 있다.
	- L : 커서를 왼쪽으로 한칸 옮김
	- D : 커서를 오른쪽으로 한칸 옮김
	- B : 커서 왼쪽에 있는 문자를 삭제
	- P $ : $라는 문자를 커서 오른쪽에 추가

1. 커서를 기준으로 **왼쪽 스택**과 **오른쪽 스택**으로 나눠서 문제를 풀 수 있다.
```
abc|xyz
(|는 커서)
```
2. L 왼쪽으로 옮김
```
ab|cxyz
```
3. D 오른쪽으로 옮김
```
abcx|yz
```
4. B 왼쪽 문자 삭제
```
ab|xyz
```
5. P$ $를 커서 왼쪽에 추가하고 커서는 $의 오른쪽에 위치
```
abcd|xyz
```

**O(N^2)**에서 스택을 사용하면 **O(N)**으로 시간복잡도가 줄어든다.

```cpp
#include <cstdio>
#include <cstring>
#include <stack>
using namespace std;
char a[600000];
int main() {
    scanf("%s",a);
    stack<char> left, right;
    int n = strlen(a);
    for (int i=0; i<n; i++) {
        left.push(a[i]);
    }
    int m;
    scanf("%d",&m);
    while (m--) {
        char what;
        scanf(" %c",&what);
        if (what == 'L') {
            if (!left.empty()) {
                right.push(left.top());
                left.pop();
            }
        } else if (what == 'D') {
            if (!right.empty()) {
                left.push(right.top());
                right.pop();
            }
        } else if (what == 'B') {
            if (!left.empty()) {
                left.pop();
            }
        } else if (what == 'P') {
            char c;
            scanf(" %c",&c);
            left.push(c);
        }
    }
    while (!left.empty()) {
        right.push(left.top());
        left.pop();
    }
    while (!right.empty()) {
        printf("%c",right.top());
        right.pop();
    }
    printf("\n");
    return 0;
}
```