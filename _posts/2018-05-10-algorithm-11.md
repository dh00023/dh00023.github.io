---
title: 11. Graph
categories:
- algorithm/ds
tag:
- c/c++
---


그래프는 자료구조의 일종으로 **정점(Node, Vertex)**과 **간선(Edge)**로 이루어져있다. 간선은 정점간의 관계를 나타내며, 정점 사이를 연결한다.

![](http://btechsmartclass.com/DS/images/Graph%201.png)

`G = (V,E)` 로 나타낸다.

일상생활에서 그래프를 예로 들어보면,

1. 지하철 역 : 정점 / 역사이 : 간선
2. 교차로 : 정점 / 도로 : 간선
3. 페이스북 사람 : 정점 / 팔로우 : 간선

이 있다.

**비선형구조**란 i번째 원소를 탐색한 다음 그 원소와 연결된 다른 원소를 탐색하려고 할 때, 여러 개의 원소가 존재하는 탐색구조를 말한다. **그래프** 도 비선형 구조이다.



## 용어

- 정점(Node, Vertex)
- 간선(Edge) : 정점간의 관계
- **경로(Path)** : 정점 A에서 B로가는 경로
  - 자동차 네비게이션 빠른길 찾기(최단 경로)
- 사이클(Cycle) or 회로 : 정점 A에서 다시 A로 돌아오는 경로 (시작 노드 == 도착 노드)
- 단순 경로와 단순 사이클 : **같은 정점을 두번 이상 방문하지 않는 경로/사이클**
  - 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클이다.
- Directed Graph(방향 있는 그래프)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Directed_graph%2C_cyclic.svg/450px-Directed_graph%2C_cyclic.svg.png)

- Undirected Graph(방향 없는 그래프 ) == Bidirection Graph(양방향 그래프)
  - A-E는 A→E와 E→A를 나타낸다.
  - 양방향 그래프는 모두 Directed Graph로 변경해서 문제를 풀 수 있다.

![](https://i.stack.imgur.com/YA7NX.png)

- Multiple Edge  : 두 정점 사이에 간선이 여러 개일 수도 있다.
  - a-c는 연결하는 간선이 2개이다.
  - 두 간선은 서로 다른 간선이다.

![](http://www.cs.rpi.edu/academics/courses/spring18/csci2600/multigraph.png)

- Loop(루프) : 간선의 양 끝 점이 같은 경우(4번)

![](http://faculty.ycp.edu/~dbabcock/PastCourses/cs360/lectures/images/lecture15/digraph.png)



- **가중치(Weight)** : 간선에 가중치가 있는 경우이다.
  - 이동 거리, 이동하는데 필요한 시간, 필요한 비용 등등등
  - 가중치가 없는 경우에는 1이라고 생각하면된다.

![](https://i.stack.imgur.com/ea2UI.png)



- 차수(degree) : 정점과 연결되어 있는 간선의 개수이다.
  - 위의 가중치 그림으로 예를 들어보자면
    - 1의 차수 : 2
    - 2의 차수 : 4
  - Directed Graph의 경우에는 차수가 두가지가 있다.
    - in-degree(정점으로 들어오는 간선의 수)
    - out-degree(정점에서 나가는 간선의 수)

## 그래프의 표현

그래프의 표현은 그래프를 저장하는 방식이다. 이때 정점의 수는 정수로 저장하게 되고, 간선은 정점 사이의 관계를 저장한다. 그러므로 간선을 저장하는 것이 그래프를 저장하는 것이다.

![](http://www.ritambhara.in/wp-content/uploads/2017/06/Screen-Shot-2017-06-10-at-7.17.01-PM.png)

보통 알고리즘 문제에서는 첫째 줄에 정점의 개수(n)과 간선의 개수(m)을 입력 받고 간선의 개수만큼 둘째 줄부터 간선의 정보를 입력 받는다.

```
// 양방향인 경우
5 6
A B
A E
B D
C D
C E
D E
```

### 인접 행렬

#### 가중치 없는 경우

정점의 개수를 V개라고 했을 때, `V*V` 크기의 이차원 배열을 이용한다.

```c
// i에서 j로 가는 간선이 있을 때
A[i][j] = 1
// i에서 j로 가는 간선이 없을 때
A[i][j] = 0
```

```
//위의 양방향 그래프
0 1 0 0 1
1 0 0 1 0
0 0 0 1 1
0 1 1 0 1
1 0 1 1 0
```

- Undirected Graph 에서는 `A[i][j] == A[j][i]` 이다.
- 없는 간선도 저장하기 때문에 잘 사용하지 않는다.(쉬운 문제를 풀 때 사용)

```cpp
#include <cstdio>

int a[10][10];
int main(){
	int n,m;
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;i++){
        int u,v;
 		scanf("%d %d",&u,&v);
        a[u][v]=a[v][u]=1; // 양방향
        //단방향인 경우에는 a[u][v]=1;만 해주면된다.
    }
}
```

#### 가중치 있는 경우

가중치가 있을 경우에는 가중치도 같이 저장해주면된다.

```c
// i에서 j로 가는 간선이 있을 때
A[i][j] = w
// i에서 j로 가는 간선이 없을 때
A[i][j] = 0
```

만약 가중치가 0<=w일 경우에는 간선이 없는 경우에는 -1을 저장해주면된다.

하지만 가중치의 범위가 정수라면! 1. 간선의 존재 여부(1,0)를 저장하는 배열 2. 가중치 정보를 저장하는 배열 을 조합해서 사용할 수 있다.

```
//위의 양방향 그래프
0 6 0 0 1
6 0 0 8 0
0 0 0 2 3
0 8 2 0 4
1 0 3 4 0
```

```cpp
#include <cstdio>

int a[10][10];
int main(){
	int n,m;
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;i++){
        int u,v,w;
 		scanf("%d %d %d",&u,&v,&w);
        a[u][v]=a[v][u]=w;
    }
}
```

#### 공간복잡도

- O(V^2)

### 인접 리스트

인접행렬은 표현할 때 연결되지 않았던 부분까지 모두 표현이 된다. 연결되지 않은 부분을 0으로 표현한다. 알고리즘을 구현할 때에도 0까지 모두 조사를 해야하므로 효율이 떨어지는 경우가 많은데 인접리스트는 이러한 단점을 극복한다.

![](https://lh3.googleusercontent.com/22poilDCWxVN7yT5qhzxdzrw8en-V9qGjiTULqjtzDisaVWc4GdhtDOoVw1EP8Dcs2wcYF8WRBH1jEdnbm9HeDMsrCxOMWWCWzpm_zy6AnU3qD4Gk_aa76mul81GkqqS0hphsA)

`std::vector()`를 이용하여 간단하게 구현할 수 있다. 이때 인접행렬로 구현하는 것보다 공간을 적게 사용한다.

#### 가중치 없는 경우

linked list를 이용해서 구현한다. 이  때 A[i]는 i와 연결된 정점을 linked list로 포함하고 있다.(i와 연결된 정점이 총 몇개인지 알 수 없기 때문이다.)

``` 
A[1] B E
A[2] A D
A[3] D E
A[4] B C E
A[5] A C D
```

이때 연결된 정점을 저장하므로 간선을 나타내게 된다. 모든 간선이 한번 씩 저장(O(E)=간선의 수)된다. 

- vector로 구현하기

그런데, linked list는 구현하는데 시간이 오래걸리기 때문에, 주로 vector와 같이 길이를 변경할 수 있는 배열을 이용해서 구현한다.

```cpp
#include <cstdio>
#include <vector>
using namespace std;
vector<int> a[10];

int main(){
	int n,m;
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;i++){
        int u,v;
 		scanf("%d %d",&u,&v);
        a[u].push_back(v);
		a[v].push_back(u);
    }
}
```

주의할점이 한가지 있다. cpp에서 vector의 표현에 주의해아한다.

- `vector<int> a(10)` 은 크기가 10인 1차원 배열을 의미한다. (=`int a[10]`)
- `vector<int> a[10]` 은 int a배열이 10개가 있다는 것을 의미한다.

```cpp
#include <cstdio>
#include <vector>
using namespace std;

int main(){
	int n,m;
    scanf("%d %d",&n,&m);
    vector<vector<int>> a(n+1);
    for(int i=0;i<m;i++){
        int u,v;
 		scanf("%d %d",&u,&v);
        a[u].push_back(v);
		a[v].push_back(u);
    }
}
```

#### 가중치 있는 경우

A[i]는 i와 연결된 정점과 그 간선의 가중치를 linked list로 포함한다.

```
A[1] (B,6) (E,1)
A[2] (A,1) (D,8)
A[3] (D,2) (E,3)
A[4] (B,8) (C,2) (E,4)
A[5] (A,1) (C,3) (D,4)
```

```cpp
#include <cstdio>
#include <vector>
using namespace std;

vector<pair<int,int>> a[10];
int main(){
	int n,m;
    scanf("%d %d",&n,&m);
;
    for(int i=0;i<m;i++){
        int u,v,w;
 		scanf("%d %d %d",&u,&v,&w);
        a[u].push_back(make_pair(v,w);
        a[v].push_back(make_pair(u,w);
    }
}
```

#### 공간복잡도

- O(E)

### 간선 리스트

STL, array list를 사용할 수 없는 경우에는 간선리스트로 그래프를 저장할 수 있다.

간선리스트는 배열을 이용해서 구현하며, 간선을 모두 저장한다.

- 앞 정점을 기준으로 정렬

```
E[0] = A B
E[1] = A E
E[2] = B A
E[3] = B D
E[4] = C D
E[5] = C E
E[6] = D B
E[7] = D C
E[8] = D E
E[9] = E A
E[10] = E C
E[11] = E D
```

- 각 간선의 앞 정점을 기준으로 개수를 센다.

| i      | 0    | 1    | 2    | 3    | 4    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- |
| cnt[i] | 0    | 2    | 2    | 2    | 3    | 3    |

- 각 정점의 간선수의 누적합을 구한다.
| i      | 0    | 1    | 2    | 3    | 4    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- |
| cnt[i] | 0    | 2    | 4    | 6    | 9    | 12   |

- i번과 연결된 간선은 E[cnt[i-1]]부터 E[cnt[i]-1]까지 이다.
  - 3번과 연결된 간선은 E[4]~E[6-1]까지

#### 공간복잡도

- O(E)



## 그래프의 탐색

그래프의 탐색의 목적은 **모든 정점을 1번씩 방문** 하는 것이다.

### DFS (깊이 우선 탐색)

그래프 중 회로가 없는 그래프를 트리라고한다.

1. 출발 정점을 트리의 가장 위에 있는 정점으로 한다.
2. 단계별 탐색을 한다.
3. 더 이상 진행할 수 없을 때는 백트랙(backtrack)-이전의 정점으로 되돌아간다.
4. 마지막 정점을 방문하면 깊이우선탐색이 완료된다.



최대한 깊숙히 많은것을 탐색할 때 사용하며, **스택을 사용**한다.

- 스택을 이용해 갈 수 있는 만큼 최대한 많이가고, 갈 수 없으면 이전 정점으로 돌아온다.
- 방문한 곳은 표시를 해둔다.(check[i] )

![](http://thumbnail.egloos.net/600x0/http://pds25.egloos.com/pds/201405/16/87/a0278987_5375e221da624.jpg)

이미 방문한 곳은 건너띄고, 갈 수 있는 곳으로 간다. 스택이 비워질 때까지 계속 pop을 한다. 스택이 비어있으면 DFS탐색이 종료된다.

#### 인접행렬 구현

dfs(x)는 x를 방문했다는 의미이다. 재귀 호출을 이용해서 구현할 수 있다.

```cpp
void dfs(int x){
    check[x] = true; //방문한 것 표시
    printf("%d ",x);
    //다음 정점 방문
    for(int i=1;i<=n;i++){
        //간선이 있고, 방문을 하지 않았을 경우
        if(a[x][i]==1 && check[i]==false) dfs(i);
    }
}
```
```cpp
//인접행렬 백트릭킹 기법
//반복문 n^2번 실행
bool visited[101];
void dfs(int k)
{
	for(int i=0;i<=n;i++)
	    if(G[k][i] && !visited[G[k][i]])
        {
        	visited[G[k][i]]=true;
            dfs(G[k][i]);
        }
    return;
}
```
- 시간복잡도 : V*O(V) = O(V^2)

#### 인접리스트 사용

항상 있는 간선만 저장한다.

```cpp
void dfs(int x){
    check[x] = true; //방문한 것 표시
    printf("%d ",x);
    //다음 정점 방문
    // a[x]는 x와 연결된 정점이다.
    for(int i=1;i<a[x].size();i++){
        int y = a[x][i];
        if(check[y]==false)dfs(y);
    }
}
```

```cpp
//인접리스트 백트랙킹 기법
//반복문 m번실행
bool visited[101];
void dfs(int k)
{
	for(int i=0;i<G[i].size();i++)
	    if(!visited[G[k][i].to])
        {
        	visited[G[k][i].to]=true;
            dfs(G[k][i]);
        }
    return;
}
```

- 모든 정점을 한번씩 거치고 모든 간선을 한번씩 검사하게 된다.
- 시간복잡도 O(V+E)



### BFS (너비 우선 탐색)

현재 정점에서 **깊이가 1인 정점을 모두 탐색한 뒤 깊이를 늘려가는 방식**이다. 너비우선탐색은 백트랙을 하지 않는다. 대신에 현재 정점에서 깊이가 1인 정점을 모두 방문해야하므로 **큐(queue)**라는 FIFO(First In First Out)자료구조를 활용해 현재 정점에서 깊이가 1 더 깊은 모든 정점을 순차적으로 큐에 저장해 탐색에 활용한다.

`std::queue()`를 활용하는 방법을 익힐 필요가 있다.



최대한 넓게 가는길을 탐색할 때 사용하며, **큐를 사용**한다.

- 큐를 이용해서 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식이다.
- BFS는 **큐에 넣을 때 방문했다고 체크**(check[i])해야한다.

![](https://shinghalrishabh.files.wordpress.com/2015/03/fig-22-3-operation-bfs.jpg)



#### 인접 행렬

```cpp
queue<int> q;
check[1]= true;
q.push(1);
while(!q.empty()){
    int x = q.front;
    q.pop();
    printf("%d ",x);
    //다음 정점을 찾기
    for(int i=1;i<=n;i++){
        if(a[x][i]==1&&check[i]==false){
            check[i]=true;
            q.push(i);
        }
    }
}
```

```cpp
//인접행렬
bool visited[101];

void bfs(int k)
{
	std::queue<int> Q;
    Q.push(k), visited[k]=1;
    while(!Q.empty())
    {
    	int current = Q.front();Q.pop();
        for(int i=0;i<G[current].size();i++)
        	if(G[current][i]&&!vistited[G[current][i]])
            {
            	visited[G[current][i]]=1;
                Q.push(G[current][i]);
            }
    }
}
```

전체 탐색하는데 있어서 반복문을 n^2번 실행하게된다.

- 시간복잡도 O(V^2)

#### 인접 리스트

```cpp
queue<int> q;
check[1]= true;
q.push(1);
while(!q.empty()){
    int x = q.front;
    q.pop();
    printf("%d ",x);
    //다음 정점을 찾기
    for(int i=1;i<a[x].size;i++){
        int y = a[x][i];
        if(check[y]==false){
            check[y]=true;
            q.push(i);
        }
    }
}
```

```cpp
//인접리스트에 저장했을 경우
#include <queue>
bool visited[101];

void bfs(int k)
{
	std::queue<int> Q;
    Q.push(k), visited[k]=1;
    while(!Q.empty())
    {
    	int current = Q.front();Q.pop();
        for(int i=0;i<G[current].size();i++)
        	if(!vistited[G[current][i]])
            {
            	visited[G[current][i]]=1;
                Q.push(G[current][i]);
            }
    }
}
```
전체를 탐색하는 데 있어서 반복문을 m번 실행하게 된다.

- 시간복잡도 O(V+E)

**최단거리를 찾는 문제**는 너비우선탐색으로 해결할 수 있는 대표적인 문제이다.(거리기록하면서 가는게 핵심)

## 문제풀어보기



### [DFS와 BFS](https://www.acmicpc.net/problem/1260)

그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>

using namespace std;
vector<int> a[1001];
bool check[1001];


void dfs(int node) {
    check[node] = true;
    printf("%d ",node);
    for (int i=0; i<a[node].size(); i++) {
        int next = a[node][i];
        if (check[next] == false) {
            dfs(next);
        }
    }
}

void bfs(int start) {
    queue<int> q;
    //memset은 메모리를 초기화 하는 함수
    //1번 파라미터는 값을 복사할 곳이고, 2번 파라미터는 초기화할 값, 마지막은 얼마만큼의 메모리를 초기화 할 것인지 하는 크기이다.
    memset(check,false,sizeof(check));
    check[start] = true;
    q.push(start);
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        printf("%d ",node);
        for (int i=0; i<a[node].size(); i++) {
            int next = a[node][i];
            if (check[next] == false) {
                check[next] = true;
                q.push(next);
            }
        }
    }
}
int main() {
    int n, m, start;
    scanf("%d %d %d",&n,&m,&start);
    for (int i=0; i<m; i++) {
        int u,v;
        scanf("%d %d",&u,&v);
        a[u].push_back(v);
        a[v].push_back(u);
    }
    for (int i=1; i<=n; i++) {
        sort(a[i].begin(), a[i].end());
    }
    dfs(start);
    puts("");
    bfs(start);
    puts("");
    return 0;
}
```



### DFS

### flood_fill

지뢰찾기, 뿌요뿌요 등 게임에서 많이 활용되는 알고리즘.
재귀함수를 이용해 깊이우선탐색을 구현한다. 하지만 재귀의 깊이가 너무 커지면 runtime error가 발생할 수 있다. 깊이가 너무 크다고 판단되면 너비우선탐색으로 처리하거나 재귀대신 스택을 이용한다.

dfs함수 부분의 4방향 탐색을 dx,dy를 이용해 작성할 수 있다.

```cpp
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};

void dfs(int a, int b, int c)
{
	A[a][b]=c;
    for(int i=0;i<4;i++)
    	if(safe(a+dx[i],b+dy[i])&&A[a+dx[i]][b+dy[i]]==1)
        	dfs(a+dx[i],b+dy[i],c);
}
```

### n-queen

n*n체스 보드판에 n개의 queen을 서로 공격하지 못하도록 배치하는 방법을 찾아내는 문제. 대각선 검사하면서 가야하는 알고리즘에 유용하다.

- 퀸은 8방향으로 모두 공격할 수 있다.


	1. 첫 번째 행, 첫 번째 열에 퀸을 놓는다.
	2. 다음 행에서 가능한 가장 왼쪽 열에 퀸을 놓는다.
	3. n번째 열에 더 이상 퀸을 놓을 수 없다면 백트랙한다.
	4. 마지막 행에 퀸을 놓으면 하나의 해를 구한 것이다.
	5. 모든 경우를 조사할 때까지 백트래킹해가며 해들을 구한다.

깊이우선탐색을 하며 해를 구할 때마다 카운트해 원하는 해를 구할 수 있다. 열과 대각선만 검사하면 된다.
대각선은 행+열 위치에 체크해 기울기가 증가하는 대각선 상에 퀸을 놓을 수 있는지 없는지 확인한다.
기울기가 감소하는 대각선은 **행과 열의 차가 일정**하다. `n+(행-열)`의 위치에 체크.
백트랙 시에 가장 중요한 점은 체크배열에 기록해 두었던 체크를 모두 해제해야한다.