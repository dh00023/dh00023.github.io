---
title: 03. Recursive
categories:
- algorithm/ds
tag:
- c/c++
---

**재귀호출**(자기 자신을 다시 호출하는 것)을 이용해서 문제를 쉽게 풀 수 있다. 정의자체가 순환적으로 되어 있는 경우에 적합하다.

순환에서 반드시 **하나 이상의 base case**가 있어야한다.

순환 알고리즘에서는 **순환 호출을 하는 부분**과 순환 호출을 **멈추는 부분**이 있다. 만약 멈추는 부분이 없다면 시스템 오류가 발생할 때까지 무한히 호출하게 된다.



## 실습

### 팩토리얼 함수

![](http://ncalculators.com/images/formulas/number-factorial-calculation.jpg)



- 순환

```c
#include <stdio.h>

int factorial(int n){
    if(n<=1) return 1;
    else return (factorial(n-1)*n);
}
```

- 반복

```c
#include <stdio.h>

int factorial(int n){
    int res = 1;
    if( n<=1 ) return res;
    else{
        for(int i = 2; i<=n;i++) res*=i;
		return res;
    }    
}
```



### 거듭제곱 구하기(x^n)

숫자 x의 n제곱 값을 구하는 문제

- 순환

```c
int power(int x, int n){
    if(n==0)return 1;
    else return (x*power(x,n-1));
}
```

이렇게 해도 되나 n이 짝수인 경우와 홀수인 경우를 나눠서 구하면 연산량이 더 줄어든다.

```c
int power(int x, int n){
    if(n==0)return 1;
    else if(n%2==0){
        return power(x*x,n/2);
    }else return x*power(x*x,(n-1)/2);
}
```

```
예시)
2^10
>> 10%2==0, power(4,5)
>> 5%2==1, 4*power(16,2)
>> 4%2==0, 4*power(256,1)
>> 1%2==1, 4*256(256*256,0) == 4*256*1
```

여기서 k번의 순환 호출이 일어난다. 한번 순환호출이 일어날때마다 1번의 곱셈과 1번의 나눗셈이 일어난다. 전체 연산 수는 k=log2(N)에 비례한다. 즉, 시간복잡도는 O(log2(n))이다.

- 반복

```c
int power(int x, int n){
    int res = 1;
    if(n==0)return res;
    else{
        for(int i=1; i<=n;i++){
            res*=x;
        }
        return res;
    }
}
```

여기서 시간복잡도는 O(n)이다.



### 피보나치 수열

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/00008893a71eebbf4e7d89a0c162fe6359f5ac8c)

피보나치 수열은 정의 자체는 순환적이나 순환 호출을 사용하면 비효율적인 대표적인 예시이다.

- 순환

```c
int fib(int n){
    if(n==0)return 0;
    if(n==1)return 1;
    return (fib(n-1)+fib(n-2));
}
```

```
fib(6)
>> fib(5) + fib(4)
>> fib(4)+fib(3) + fib(3)+fib(2)
>> fib(3)+fib(2) + fib(2)+fib(1) + fib(2)+fib(1) + fib(1)+fib(0)
```

위와 같이 같은 항이 계속해서 중복해서 계산되므로 비효율 적이다.

- 반복

```c
int fib(int n){
    if(n<2)return n;
    else{
    	int i, current=1, last=0, tmp;
        for(i=2;i<=n;i++){
 			tmp = current;
 			current += last;
 			last = tmp;
        }
        return current;
    }
}
```



### Tripple 피보나치 수열

1, 2, 3, 6, 11, 20, 37, 68 ...

- 순환

```c
int fib_tri(int n){
    if(n==0) return 0;
    if(n==1) return 1;
    if(n==2) return 2;
    else{
 	     return  fib_tri(n-3)+fib_tri(n-2)+fib_tri(n-1);
    }
}
```



###  하노이 탑

막대 A에 있는 원판을 막대 C로 옮기는 문제이다.

**조건**

1. 한 번에 하나의 원판만 이동할 수 있다.
2. 맨 위에 있는 원판만 이동할 수 있다.
3. 크기가 작은 원판 위에 큰 원판이 쌓일 수 없다.
4. 중간의 막대를 임시적으로 이용할 수 있으나 앞의 조건들을 지켜야 한다.

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ8vudlhhc4OZz1XrdvaWkNXTvCWMRnZvsbXdcPAHNOWuaYHuub)

1단계. 막대 A에서 원반(1~n-1)을 막대 C를 이용해 막대 B로 옮긴다. **Hanoi(m-1,a,c,b)**

2단계. 막대 A에서 원반(n)을 막대 C로 옮긴다. if(m==1)

3단계. 막대 B에서 원반(1~n-1)을 막대 A를 이용해 막대 C로 옮긴다. **Hanoi(m-1,b,a,c)**

- 순환

```c
void hanoi(int n, char a, char b, char c){
	if(n==1)printf("원반%d이 막대[%c]에서 막대[%c]로 옮겨집니다.",n,a,c);
    else{
        hanoi(n-1,a,c,b);
        printf("원반%d이 막대[%c]에서 막대[%c]로 옮겨집니다.",n,a,c);
        hanoi(n-1,b,a,c);
    }
}
```



### Ackermann 함수

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/1a15ea2fcf1977e497bccdf1916ae23edc412fff)

[위키백과 아커만 함수](https://ko.wikipedia.org/wiki/%EC%95%84%EC%BB%A4%EB%A7%8C_%ED%95%A8%EC%88%98)에 함수에 대한 자세한 설명이 있다.

- 순환

```c
int ackermann(int m, int n){
    if(m==0)return n+1;
    if(m>0 && n==0)return ackermann(m-1,1);
	return ackermann(m-1,ackermann(m,n-1));
}
```

- 반복

basecase가 없다면 순환이 아니다! 이것에 초점을 두고 코드를 짜보았다. 

```c
int ackermann_loop(int m, int n){
    int mm = m, nn = n;
    while(mm!=0){
        if(nn == 0) nn = 1;
        else nn = ackermann_loop(mm,nn-1);
        mm--;
        printf("nn : %d \n",nn);
    }
    return nn+1;
}
```

2차원 배열로 구현했을 때는 범위를 지정해주지 않으면 계속해서 범위를 초과하는 문제발생했다.

```c
int A[100][100];
int ackermann_loop(int m, int n){
    for(int i = 0;i<=m;i++){
        for(int j = 0; j<=50; j++){
            if(i==0)A[i][j]=n+1;
            else if(j==0)A[i][j]=A[i-1][j];
            else{
                int tmp = A[i][j-1];
                A[i][j] = A[i-1][tmp];
            }
        }
    }
    return A[m][n];
}
```

또 규칙을 찾아서 구현하는 방법도 있다.

```c
int Acker_nonrecursive3(int m, int n)
     int i;
     int val=2;

     if(m==0) return n+1;
     if(m==1) return n+2;
     if(m==2) return 2*n+ 3;
     if(m==3) {  
        // return pow(2, n+3) -3;  또는 아래 for loop 으로 
		for(i=1; i<n+3; i++)
			val *=2;

		return val -3;
     }

     if(m==4){
		for(i=1; i< n+3; i++)
			val *=val;
		return val=val-3;
     }
}
```

